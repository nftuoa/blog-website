---
title: " CS61B要点速记 "
author: "Oscar Tuo"
date: "2025-09-23"
categories: [Java]

---

听CS61B听到第四节写disc发现前面忘光了，所以决定写个这个备作复习

## main函数定义
```java
public static void main(String[] args)
```

## Static Typing
Java变量必须有唯一确定的类型，一经定义不能改变

## 函数即方法

Java的所有函数必须在类内定义，也就是方法
一个项目里的类不用import就能用

## 实例和实例方法
类的实例化函数通过
```java
public className(){
}

```
定义
```Java
public static typename funcname(){
}
``` 
这种是静态方法，可以直接从类名调用，但是相应地也调用不了实例的变量和函数

```java
public typename funcname(){
}
```
这种是实例方法，实例化以后才可以调用，可以调用当前实例内的变量和其他方法

实例化函数和实例方法不用把self当参数传入
通过`self.funcname`/ `self.varname`或者直接`funcname`/`varname`调用实例内变量与方法效果是一样的

相似地，通过`public static typename varname/funcname` 可以定义静态变量，通过`public typename varname/funcname` 可以定义实例变量

实例变量也必须在类的声明中声明，实例化以后不能再添加新的变量

实例化后，实例只会引用其类的静态变量而不会专门初始化一个自己的，也就是说改了类里的静态变量它的实例都会跟着改

public的意思是同一个项目里的其他对象也可以访问，private是该类/该实例私有的

如果变量/方法前边没有public也没有private，那么它就是package-private的，也就是对同一个package内public，之外则private，package需要自己定义

## List

首先需要
```java
import java.util.List
```
但是
```java
List L = new List();
```
不会被编译，这是因为List是一个抽象类(只作别人的基类，自己不能实例化)
需要
```java
import java.util.ArrayList
```
然后再
```java
List L = new ArrayList()
```
或其他List类型，比如LinkedList

也就是说:List是抽象数据类型，LinkedList/ArrayList等是它的具体实现

通过
```java
L.get(0)
```
可以索引列表
 
通过
```java
List<String> L = new ArrayList<>()
```
可以指定存储的数据类型

### Array
一种特殊的类List实现，但不属于List ADT
通过
```java
int[] x = new int[5];
```
即可声明，无需import任何包
但是容量必须声明固定，不包含任何内置方法，只能用[]来索引

## Map

也就是键值对
Map也是ADT，常用的实现有HashMap和TreeMap
```java
Map<String, String> L = new TreeMap<>();

    L.put("dog", "woof");

    L.put("cat", "meow");
```
TreeMap自带升序排序，HashMap不会自动排序

## Primitive Types & Reference Types


byte, short, int, long, float, double, boolean, char八种类型叫Primitive Type，也就是所谓的基本类型

基本类型变量直接对应内存地址
使用类似
```java
int y = 1;
int x = y;
```
的语法从一个基本类型变量给另一个赋值时，会直接把源变量的所有字节直接复制给目标变量
其他的都是Reference Type,也就是引用类型，实际上就是对象
创建引用类型时会先创建一个该类型的对象并填入默认值，然后调用构造函数填入输入值，最后返回这个对象的一个64位的地址
也就是说引用类型里实际上存的只是地址，当你赋值的时候复制过去的时候也只是地址，那么就会发现两个引用类型变量却指向的是同一个对象

函数里传参也遵守类似的规则
前面讲到的List、Array等等也是对象，因此使用`==`比较时实际上比较的是内存地址，要比较内容需要用`equals`

## IntList

```java
public class IntList {

   public int first;

   public IntList rest;

  

   public IntList(int f, IntList r) {

      first = f;

      rest = r;

   }
	public int size() {

      if (rest == null) {

         return 1;

      }

      return 1 + this.rest.size();
      }
public int iterativeSize() {

      IntList p = this;

      int totalSize = 0;

      while (p != null) {

         totalSize += 1;

         p = p.rest;

      }

      return totalSize;

   }
   }
```

课程里的这个IntList实际上是个链表

size是递归实现的size函数，iterativeSize则是迭代实现的

