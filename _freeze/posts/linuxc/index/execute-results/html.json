{
  "hash": "857c3b992ae9bbbc3e5ced56b1d6e46c",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 《Linux C编程一站式学习》习题解答\nauthor: Oscar Tuo\ndate: 2025-01-29\ncategories:\n  - programming\n---\n\n**学这本书主要是为了满足[ysyx](http://ysyx.oscc.cc)的要求,故会先以一个较快的速度更新完ysyx要求的部分(第1-9章, 第11-16章, 第21章, 第23-25章, 以及第26章第1节),未经特殊标记的程序默认采用C17标准编译通过。**\n\n编译环境:AMD Ryzen 7 7840HS,EndeavourOS x86-64,Linux 6.12.10,gcc 14.2.1(标了C23的用的是15.0)；跑不通的建议先想想是不是Windows的问题,再想想是不是英特尔的问题,再想想是不是Clang的问题\n\n你可以在这里读到这本书: https://akaedu.github.io/book/index.html \n\n\n\n## 第二章\n### 习题2-2\n```c\n#include <stdio.h>\nint main(void)\n{\n\tprintf(\"%%\\n\");\n}\n```\n### 习题2-5\n```c\n#include <stdio.h>\n#include <math.h>\nint main(void)\n{\n\tprintf(\"%d\\n\",(int)ceil(17.0/4));\n}\n```\n## 第三章\n\n### 习题3-3\n\n#### 1.\n不能increment里的x是形参，不会影响传进去的实参\n\n#### 2.\nprintf在stdio.h里，不把stdio.h给include进去的话printf没有定义\n\n## 第四章\n\n### 习题4-1\n错误:if的条件满足后会执行一个空语句，下面那行并没有被if的判定所限制\n\\\n编译能通过:没有语法错误\n\n### 习题4-2\n\n#### 1.\nx%10;(int) (x%100)/10\n\n#### 2.\n```c\nvoid printdigit(int x)\n{\n\tprintf(\"%d,%d\\n\",x%10,(int) (x%100)/10)\n}\n```\n\n### 习题4-3\n\n#### 1.\n```c\nif (x>=10 || x<=0)\n\tprintf(\"x is out of range\\n\");\n```\n\n#### 2.\n```c\nif (x<=0 && y<=0)\n\tprintf(\"test failed!\\n\");\nelse\n\tprintf(\"test ok!\\n\");\n```\n\n#### 3.\n```c\ny=1 || x=1\n```\n\n#### 4.\n\n**总之是第二个**\n\n\n\n## 第五章\n\n### 习题5-1\n\n#### 1.\n\n*请用C23编译*\n```c\n\nbool is_leap_year(int year)\n{\n\tif(year%4!=0 || (year%100==0 && year%400!=0))\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\n```\n\n#### 2.\n```c\n#include <math.h>\ndouble myround(double x)\n{\n  if(x<0)\n    return ceil(x-0.5);\n  else \n    return floor(x+0.5);\n}\n```\n*用gcc编译的话请加入-lm参数,我也不知道这个大哥为什么默认不会去找math.h*\n\n### 习题5-3\n\n#### 1.\n```c\nint euclid(int a, int b)\n{\n\tif (a%b==0)\n\t\treturn b;\n\telse\n\t\treturn(euclid(b,a%b));\n}\n```\n证明交给屏幕前的各位未来的yau们自己完成(\n\n#### 2.\n```c\nint fibo(int n)\n{\n\tif (n==0||n==1)\n\t\treturn 1;\n\telse\n\t\treturn(fibo(n-1)+fibo(n-2));\n}\n```\n\n## 第六章\n\n### 习题6-1\n\n#### 1.\n*用循环写递归本质上就是让你的脑子递归*\n\n##### (1).\n```c\nint euclid(int a,int b)\n{int remain = 1;\nwhile (remain!=0)\n{\n\tremain = a%b;\n\ta = b;\n\tb = remain;\n}\nreturn a;}\n```\n\n##### (2).\n```c\nint fib(int n){\nint fibo[100];\nfibo[0]=1;\nfibo[1]=1;\nfor(int i = 2;i<=n;i++)\n{\n\tfibo[n]=fibo[n-2]+fibo[n-1];\n}}\n```\n\n#### 2.\n```c\nint nine(void){\nint nines=0;\nfor(int i = 1;i<101;i++)\n{\n\tif ((i%10)==9||((int) i/10) == 9)\n\tnines++;\n}\nreturn nines;\n```\n\n### 习题6-4\n\n#### 1.\n```c\n#include <stdio.h>\nint is_prime(int n)\n{\n\tint i=2;\n\twhile(i < n && (n % i) !=0)\n\t\ti++;\n\tif (i == n)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nint main(void)\n{\n\tint i;\n\tfor (i = 1; i <= 100; i++) {\n\t\tif (is_prime(i))\n\t\tprintf(\"%d\\n\", i);\n\t}\n\treturn 0;\n}\n```\n\n#### 2.\n可能会有某几次循环表达式3没有被执行\n\n### 习题6-5\n\n#### 1.\n```c\n#include <stdio.h>\n\nint main(void)\n{\n\tint i, j;\n\tfor (i=1; i<=9; i++) {\n\t\tfor (j=1; j<=9; j++)\n\t\t\tif(j<=i)\t\n\t\t\tprintf(\"%d\\t\", i*j);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n```\n\n#### 2.\n```c\nvoid diamond(int n,char s)\n{\n  if(n%2==0)return;\n  for(int i = 1;i<=n;i+=2)\n  {\n    for(int t = 0;t<(n-i)/2;t++)printf(\" \");\n    for(int t = 0;t<i;t++)\n      printf(\"%c\",s);\n    printf(\"\\n\");\n  }\n  for(int i = n-2;i>0;i-=2)\n  {\n    for(int t = 0;t<(n-i)/2;t++)printf(\" \");\n    for(int t = 0;t<i;t++)\n      printf(\"%c\",s);\n    printf(\"\\n\");\n  }\n}\n```\n\n## 第七章\n\n### 习题7-2\n\n#### 1.\n\n```c\n#include <stdio.h>\nstruct complex_struct{\n\tdouble x,y;\n};\nvoid output_complex(struct complex_struct a){\n\tif(a.x!=0)\n  {\n    printf(\"%.2lf\",a.x);\n    if(a.y!=0)printf(\"+\");\n    else printf(\"\\n\");\n  }\n\n  if(a.y!=0)\n\tprintf(\"%.2lfi\\n\",a.y);\n}\nint main(void)\n{\n\tstruct complex_struct a = {1,2};\n\tstruct complex_struct b = {0,1};\n\tstruct complex_struct c = {1,0};\n\toutput_complex(a);\n\toutput_complex(b);\n\toutput_complex(c);\n}\n```\n\n#### 2.\n\n```c\n#include <stdio.h>\n\nstruct rational{\n  int num,deno;\n};\n\n\nint euclid(int a, int b)\n{\n\tif (a%b==0)\n\t\treturn b;\n\telse\n\t\treturn(euclid(b,a%b));\n}\nstruct rational elliminate(struct rational c)\n{\n  int factor = euclid(c.num,c.deno);\n  c.num = c.num/factor;\n  c.deno = c.deno/factor;\n  return c;\n}\nstruct rational add_rational(struct rational a, struct rational b)\n{\n  struct rational sum;\n  sum.num = a.num*b.deno + b.num*a.deno;\n  sum.deno = a.deno*b.deno;\n  sum = elliminate(sum);\n  return sum;\n}\nstruct rational sub_rational(struct rational a, struct rational b)\n{\n  struct rational differ;\n  differ.num = a.num*b.deno - b.num*a.deno;\n  differ.deno = a.deno*b.deno;\n  differ = elliminate(differ);\n  return differ;\n}\nstruct rational mul_rational(struct rational a, struct rational b)\n{\n  struct rational product;\n  product.num = a.num*b.num;\n  product.deno = a.deno*b.deno;\n  product = elliminate(product);\n  return product;\n}\nstruct rational div_rational(struct rational a, struct rational b)\n{\n  struct rational quotient;\n  quotient.num = a.num*b.deno;\n  quotient.deno = a.deno*b.num;\n  quotient = elliminate(quotient);\n  return quotient;\n}\nstruct rational make_rational(int a, int b)\n{\n  struct rational c;\n  c.num = a;\n  c.deno = b;\n  return c;\n}\nvoid print_rational(struct rational a)\n{\n  if(a.deno!=1)\n    printf(\"%d/%d\\n\",a.num,a.deno);\n  else\n    printf(\"%d\\n\",a.num);\n}\nint main(void)\n{\n\tstruct rational a = make_rational(1, 8); /* a=1/8 */\n\tstruct rational b = make_rational(-1, 8); /* b=-1/8 */\n\tprint_rational(add_rational(a, b));\n\tprint_rational(sub_rational(a, b));\n\tprint_rational(mul_rational(a, b));\n\tprint_rational(div_rational(a, b));\n\n\treturn 0;\n}\n\n```\n\n### 习题7-3\n\n#### 1.\n\n```c\n\n#include <stdio.h>\n#include <math.h>\n\nenum coordinate_type { RECTANGULAR, POLAR };\nstruct complex_struct {\n\tenum coordinate_type t;\n\tdouble a, b;\n};\nstruct complex_struct make_from_real_img(double x, double y)\n{\n\tstruct complex_struct z;\n\tz.t = RECTANGULAR;\n\tz.a = x;\n\tz.b = y;\n\treturn z;\n}\nstruct complex_struct make_from_mag_ang(double r, double A)\n{\n\tstruct complex_struct z;\n\tz.t = POLAR;\n\tz.a = r;\n\tz.b = A;\n\treturn z;\n}\n\ndouble real_part(struct complex_struct in)\n{\n  if (in.t == RECTANGULAR)\n    return in.a;\n  else \n    return (in.a*cos(in.b));\n}\n\ndouble img_part(struct complex_struct in)\n{\n  if (in.t == RECTANGULAR)\n    return in.b;\n  else \n    return (in.a*sin(in.b));\n}\n\ndouble magnitude(struct complex_struct in)\n{\n  if (in.t == POLAR)\n    return in.a;\n  else \n    return sqrt(in.a*in.a+in.b*in.b);\n}\n\ndouble angle(struct complex_struct in)\n{\n  if (in.t == POLAR)\n    return in.b;\n  else \n    return atan(in.b/in.a);\n}\n\nint main(void)\n{\n  struct complex_struct a = make_from_real_img(2,3);\n  struct complex_struct b = make_from_mag_ang(1,2);\n  printf(\"%lf %lf %lf %lf %lf %lf %lf %lf\\n\",real_part(a),real_part(b),img_part(a),img_part(b),magnitude(a),magnitude(b),angle(a),angle(b));\n  return 0;\n}\n\n```\n\n*使用gcc编译时请加入-lm指令，main函数主要是用来测试*\n\n#### 2.\n```{asciinema}\nenumtest.cast\ncols: 80\nrows: 7\nautoPlay: true\nspeed: 4\ntheme: nord\nposter: \"npt:1:23\"\n```\n\n原因:enum里的RECTANGULAR被后边的初始化语句在main里给覆盖了，而POLAR则还是定义的2\n\n## 第八章\n\n### 习题8-1\n\n```c\n#include <stdio.h>\n#include <string.h>\nint main(void)\n{\n  int a[5]={5,4,3,2,1};\n  int b[5];\n  memcpy(b,a,sizeof(a));\n}\n```\n\n### 习题8-2\n\n```c\nrand()%11+10\n```\n\n## 第十章\n\n暂缺...\n\n## 第十一章\n\n### 习题11-4\n\n```c\n#include <stdio.h>\nint a[10]={1,2,3,4,5,6,7,8,9,0};\nint partition(int start, int end)\n{\n\t/*从a[start..end]中选取一个pivot元素（比如选a[start]为pivot）;\n\t在一个循环中移动a[start..end]的数据，将a[start..end]分成两半，\n\t使a[start..mid-1]比pivot元素小，a[mid+1..end]比pivot元素大，而a[mid]就是pivot元素;*/\n\tint mid = (int) (start+end)/2;\n  for (int i = start;i<mid;i++)\n  {\n    if(a[i]>a[mid])\n    {\n      int temp=a[i];\n      for(int t = i;t<mid;t++)\n      {\n        a[t]=a[t+1];\n      }\n      a[mid]=temp;\n      mid--;\n    }\n  }\n  for (int i = end;i>mid;i--)\n  {\n    if(a[i]<a[mid])\n    {\n      int temp=a[i];\n      for(int t = i;t>mid;t--)\n      {\n        a[t]=a[t-1];\n      }\n      a[mid]=temp;\n      mid++;\n    }\n  }\n\n  return mid;\n}\n\nvoid quicksort(int start, int end)\n{\n\tint mid;\n\tif (end > start) {\n\t\tmid = partition(start, end);\n\t\tquicksort(start, mid-1);\n\t\tquicksort(mid+1, end);\n\t}\n}\n\nint main(void)\n{\n  quicksort(0,9);\n  for(int i = 0;i<10;i++)printf(\"%d\\n\",a[i]);\n}\n```\n\n*我估计这个应该不是最优算法,在原书内含和partition函数以外的部分都是用于测试*\n\n### 习题11-5\n\n#### 1.\n没有，至少得把每个元素都遍历一遍才能确定是最小的\n\n#### 2.\n\n```c\n#include <stdio.h>\n\nint main(void)\n{\n  int data[5] = {1,2,3,4,5};\n  int min=1,second=2;\n  for(int i = 1;i<5;i++)\n  {\n    if (data[i]<=second && data[i] >= min)\n      second = data[i];\n    else if (data[i]<=min)\n      min = data[i];\n  }\n  printf(\"%d\\n\",second);\n}\n```\n\n我不是很确定这个的复杂度算不算是n\n\n#### 3.\n\n```c\n#include <stdio.h>\n\n\nint a[5] = {1,2,3,4,5};\n\nint partition(int start, int end)\n{\n\tint mid = (int) (start+end)/2;\n  for (int i = start;i<mid;i++)\n  {\n    if(a[i]>a[mid])\n    {\n      int temp=a[i];\n      for(int t = i;t<mid;t++)\n      {\n        a[t]=a[t+1];\n      }\n      a[mid]=temp;\n      mid--;\n    }\n  }\n  for (int i = end;i>mid;i--)\n  {\n    if(a[i]<a[mid])\n    {\n      int temp=a[i];\n      for(int t = i;t>mid;t--)\n      {\n        a[t]=a[t-1];\n      }\n      a[mid]=temp;\n      mid++;\n    }\n  }\n\n\n  return mid;\n}\n\nvoid quicksort(int start, int end)\n{\n\tint mid;\n\tif (end > start) {\n\t\tmid = partition(start, end);\n\t\tquicksort(start, mid-1);\n\t\tquicksort(mid+1, end);\n\t}\n}\n\nint order_statistic(int start, int end, int k)\n{\n\tint i = partition(start,end);\n\tif (k-1 == i)\n\t  return a[i];\n\telse if (k >= i)\n  {\n    quicksort(i+1,4);\n    return a[k-1];\n  }\n\telse\n  { \n    quicksort(0,i-1);\n    return a[k-1];\n  }\n}\n\nint main(void)\n{\n  printf(\"%d\\n\",order_statistic(0,4,1));\n}\n```\n\nds说这个的平均复杂度接近$$n^2$$,我不太相信但是这个的平均复杂度肯定比n大得多，我还需要再钻研一下。\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}