[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "I don’t know what makes me real, maybe it’s the current moment, or maybe it’s you."
  },
  {
    "objectID": "posts/csapp1/index.html",
    "href": "posts/csapp1/index.html",
    "title": "《CS:APP》学习笔记(1)计算机系统巡游",
    "section": "",
    "text": "作为一名身在EE心在CS的不合格EE新生1,CMU的神课Computer Systems:A Programmer’s Perspective一直令我神往,故而下载了教材阅读,并顺便记录笔记供自查与分享。\n文中可能会有各种难以理解的名词,它们会在随后的章节中被解释,我之所以不在这里解释是因为我也还不会（。"
  },
  {
    "objectID": "posts/csapp1/index.html#写在前面",
    "href": "posts/csapp1/index.html#写在前面",
    "title": "《CS:APP》学习笔记(1)计算机系统巡游",
    "section": "",
    "text": "作为一名身在EE心在CS的不合格EE新生1,CMU的神课Computer Systems:A Programmer’s Perspective一直令我神往,故而下载了教材阅读,并顺便记录笔记供自查与分享。\n文中可能会有各种难以理解的名词,它们会在随后的章节中被解释,我之所以不在这里解释是因为我也还不会（。"
  },
  {
    "objectID": "posts/csapp1/index.html#信息二进制位语境",
    "href": "posts/csapp1/index.html#信息二进制位语境",
    "title": "《CS:APP》学习笔记(1)计算机系统巡游",
    "section": "信息=二进制位+语境",
    "text": "信息=二进制位+语境\n#include &lt;stdio.h&gt;\nint main(void){\n    printf(\"Hello, World!\");\n}\n这是一个最简单的”Hello, World”C程序,计算机在存储它时通过ASCII标准将其中的字符与换行转化为ASCII码,并以ASCII码的形式储存。存储在计算机中的这段程序其实只是一串有顺序的二进制位,这些二进制位的每八位组成一个”字节”,每个字节都代表其中的一个字符。 其他数据也采用了相同的表达方式：在不同的语境中,一串相同的字节可能是整数、浮点、字符串、机器指令、etc。"
  },
  {
    "objectID": "posts/csapp1/index.html#程序被其他程序翻译为各种形式",
    "href": "posts/csapp1/index.html#程序被其他程序翻译为各种形式",
    "title": "《CS:APP》学习笔记(1)计算机系统巡游",
    "section": "程序被其他程序翻译为各种形式",
    "text": "程序被其他程序翻译为各种形式\nC语言是一种高级语言,这也就是说计算机并不能直接执行,而需要其他程序将其翻译为计算机能够执行的机器语言。机器语言以二进制文件储存在磁盘中,以”目标程序”的形式储存。 这个过程叫做编译,由被称为编译系统的一系列程序构成。编译系统主要包括四部分:预处理器、编译器、汇编器和链接器;分别对应编译过程的四步。下面以前面的”Hello, World”为例分别介绍这四步。\n\n预处理阶段\n预处理器检测C程序中#开头的部分并生成处理过的新C程序文件,例如在这一程序的编译中,预处理器cpp会检测到#include&lt;stdio.h&gt; 并将stdio.h直接插入到原程序文件中,这一步的处理结果一般会带有.i后缀。\n编译阶段\n编译器会将预处理得到的.i文件翻译为一个汇编语言程序,汇编语言是一种低级语言(但是人类依然还能理解一部分),使用不同的编译器编译不同的语言程序都会先得到汇编程序。汇编程序一般带有.s后缀。\n汇编阶段\n汇编器会将汇编程序.s文件翻译为二进制形式的机器指令,并将其封装在一个”可重定位目标文件”中,这类文件一般带有.o后缀,人类已经无法直接理解它了。\n链接阶段\n我们的Hello, World程序中调用了printf函数,但在生成的hello.o文件中并不包括printf的实现。链接器会将存储在系统中的printf.o与汇编得到的hello.o链接在一起,生成最终可供执行的”可执行目标程序”。"
  },
  {
    "objectID": "posts/csapp1/index.html#编译原理值得了解",
    "href": "posts/csapp1/index.html#编译原理值得了解",
    "title": "《CS:APP》学习笔记(1)计算机系统巡游",
    "section": "编译原理值得了解",
    "text": "编译原理值得了解\n理解编译原理有利于： 1. 优化程序性能 2. 理解链接错误 3. 避免安全漏洞"
  },
  {
    "objectID": "posts/csapp1/index.html#处理器读取并处理内存中存储的指令",
    "href": "posts/csapp1/index.html#处理器读取并处理内存中存储的指令",
    "title": "《CS:APP》学习笔记(1)计算机系统巡游",
    "section": "处理器读取并处理内存中存储的指令",
    "text": "处理器读取并处理内存中存储的指令\n我们可以利用Shell来运行我们编写的Hello程序。Shell是一种命令行解释程序,这意味着它接受命令行输入并执行。我们在Shell中输入./hello, Shell会检测到hello是一个可执行文件，并将它加载到内存中后执行。程序执行完成后，Shell会继续请求命令行输入。\n\n计算机系统的硬件组成\n\n总线\n总线是沿着整个系统运行的一系列电子线路的集合。总线可以将信息位在元件之间来回传输, 总线一般所传输的信息位数是固定的, 这些字节的组块被称作“语词”, “语词”长度一般为4字节(也就是32位)或8字节(也就是64位)\n\n\nI/O 设备\nI/O设备以输入或输出的方式建立计算机与外界的连接。I/O设备通过控制器或者适配器连接到I/O总线。控制器是主板上的专门芯片，适配器则是一些连接在主板上的设备。\n\n\n主内存\n主内存是一种临时储存设备，在处理器执行程序时会将程序与对应的数据暂存进内存。内存一般采用DRAM(Dynamic Random Access Memory,动态随机访问存储)技术。在软件层面内存会被抽象为一系列线性的数组，并从0开始编号，这一编码被称为内存地址。\n\n\n处理器\n这里的处理器是一般说的中央处理器(CPU)，是处理并执行内存中存储的指令的元件。在其中有一个单个语词长度的寄存器,被称作PC(Program Counter,程序计数器)。PC在运行中指向内存中的某条机器语言指令(也就是现在要运行的)。 只要计算机接电，处理器就会不断执行程序计数器所指的那条指令，程序会主动更新程序计时器以便执行下一条命令。处理器根据其指令集(ISA)的不同，具有其独有且唯一的指令执行模型，其中包括执行指令的顺序与执行指令的一系列步骤。 CPU能执行的指令实际上只有简单的几条，它们都围绕着内存、寄存器与ALU（算术/逻辑单元）展开，例如Load(从内存向寄存器加载指令)，Store(从寄存器向内存写入数据)，Operate(利用ALU执行)及Jump(利用PC加载下一条指令)\n\n\n\nHello程序的执行\n向Shell输入./hello后，shell会将程序中的指令与数据加载到内存中。 通过DMA技术，数据可以不经CPU直接写入内存。 在程序加载进内存后，处理器会开始执行内存里的机器码。具体来说，这些用机器码表示的指令会把hello,world\\n放进寄存器，然后再从寄存器输出到显示设备。"
  },
  {
    "objectID": "posts/csapp1/index.html#缓存的重要性",
    "href": "posts/csapp1/index.html#缓存的重要性",
    "title": "《CS:APP》学习笔记(1)计算机系统巡游",
    "section": "缓存的重要性",
    "text": "缓存的重要性\n在磁盘与内存之间移动数据往往会消耗很长时间，甚至成为程序运行的性能瓶颈；因此优化这些拷贝工作的耗时非常重要。 由于物理规律的限制，往往容量越大的存储设备速度就会越慢；而快速的存储器不但容量小，造价也十分昂贵。例如硬盘可能有千倍于内存的容量，但同时速度可能只有内存的千万分之一；而处理器的内置寄存器则容量更小，但是速度比起内存还要快上百倍，而且由于处理器性能的发展，这个比例可能还会继续增长。 这就导致内存与寄存器之间产生了巨大的鸿沟，为了填补这个鸿沟，我们引入了缓存作为内存与寄存器之间的缓冲区。缓存一般有2-3级，级数越高越大(并且慢)；通过将常用或者即将要再次使用的数据与指令暂存在更靠近处理器、速度比内存快得多的缓存之中，可以使大部分的内存操作都在处理器片内执行，性能大大提高。"
  },
  {
    "objectID": "posts/csapp1/index.html#操作系统管理硬件",
    "href": "posts/csapp1/index.html#操作系统管理硬件",
    "title": "《CS:APP》学习笔记(1)计算机系统巡游",
    "section": "操作系统管理硬件",
    "text": "操作系统管理硬件\n软件并不能直接访问硬件，而要通过操作系统的中介。操作系统作为中间层有两层好处：1.阻挡软件错误使用硬件 2.包装抽象的底层硬件，提高软件通用性。\n\n进程\n操作系统将程序抽象为进程来运行，在进程中，每个程序都以为自己是当前系统运行的唯一程序，自己的数据是内存中仅有的数据。一个系统里通常都会有很多进程，它们“见缝插针”地交错运行。 传统系统中，一个CPU理论上只能执行一个线程的任务。而现代操作系统通过“上下文切换”，可以在多个进程之间切换，并保存其各自实时状态。 操作系统的内核是一系列一直在内存里待命的代码，应用程序可以通过System Call来调用它，让它完成读写文件之类的工作。\n\n\n线程\n现代处理器的执行单元被称为线程，一般有很多个。进程正是在线程中运行，每个线程内部都有共享的代码与全局数据。线程也可以看作核心的抽象，但线程间通信明显会比核心间通信方便不少；在多核心系统中，面向线程进行程序设计可以提高运行效率。\n\n\n虚拟内存\n操作系统会将内存抽象为虚拟地址空间。虚拟地址空间被划分为不同的区域，这些区域从下到上分别是：程序的代码与数据、堆、共享库、栈与内核虚拟内存。\n\n\n文件\n(类)Unix系统里，各种I/O设备都被抽象为文件，对它们的操作全部通过文件读写实现，这部分System Call叫作Unix I/O。"
  },
  {
    "objectID": "posts/csapp1/index.html#系统间的网络通讯",
    "href": "posts/csapp1/index.html#系统间的网络通讯",
    "title": "《CS:APP》学习笔记(1)计算机系统巡游",
    "section": "系统间的网络通讯",
    "text": "系统间的网络通讯\n网络也可以被看做一个Unix I/O设备来操作。 两个终端系统中间通过服务器传输数据。 ## 一些重要的概念 ### 阿姆达尔定律\n假设系统的一个部分占用系统运行时间的比例为\\(\\alpha\\)，而这一部分的性能提升到了原来的k倍，则提速倍数（原耗时/新耗时） \\(S=1/((1-\\alpha)+\\alpha/k)\\)\n\n并发与并行\n\n线程级别的并发\n传统的并发是在单CPU上实现的，处理器不断地在任务之间切换，模拟出了并发执行的效果，仅通过这种技术便可以实现多任务。 而近年来我们则有了更多选择。一是处理器的核心开始变多，而每个核心都有自己的独立L1、L2缓存，可以真正意义上同时运行多个任务。 二是超线程技术。这种技术可以让一个核心执行多个控制流，传统处理器经过数万个周期才能切换到另一个线程，而带有超线程的CPU核心每个周期都可以选择执行哪个线程的人物，这使得运算单元的空闲时间得到重复呢利用，有效提升了效率。 如果程序编写时针对多线程做了优化，那么即使仅运行这一个程序，并发也会带来性能提升。\n\n\n指令级别的并行\n现代处理器可以在一个周期内同时执行多条指令。\n\n\n单指令、多数据(SIMD)的并行\n现代处理器也可以同时对多组数据进行同样的运算，然后同时得出结果。\n\n\n\n抽象的重要性\n处理器方面：指令集 操作系统方面： I/O抽象为文件、内存抽象为虚拟地址空间、程序抽象为进程等等\n(Finished on Friday 31, October 2025)"
  },
  {
    "objectID": "posts/csapp1/index.html#footnotes",
    "href": "posts/csapp1/index.html#footnotes",
    "title": "《CS:APP》学习笔记(1)计算机系统巡游",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n情况发生了一些变化。请参照最后一段。↩︎"
  },
  {
    "objectID": "posts/glory2/index.html",
    "href": "posts/glory2/index.html",
    "title": "新年特辑 | 翻译 《荣光与梦想——美国历史纪实：1932-1972年》第二章·“罗斯福！”",
    "section": "",
    "text": "总统大选后不久，一群共产主义者突如其来地到达了东六十五街的49号(译者注:罗斯福那时的办公室)。当选总统款待了他们，但是当其中一人说“我们想要您告诉胡佛总统联邦政府必须……”时，罗斯福严厉地打断了他。“我不能让总统干任何事，”他说道，“在联邦政府的角度下，我现在不过只是一介草民。”他想表达的也的确是这个意思。在获得可以行使的权力前，他并不会插手这些事务。而在这段时间，他去文森特·阿斯特的游艇上捕鱼，选了一套不怎么引人注目的内阁，并且似乎对身边所有人都表示赞同。那位正努力抗衡阿肯色州参议员约瑟夫·鲁滨逊的保守派淫威的休伊·朗评价当选总统道“当我跟他讲话时，他说‘对！对！对！’，但是第二天鲁滨逊去找他，他也说‘对！对！对！’说不定他对所有人都是这么讲的。”社会崩溃的速度实在太快了(甚至埃莉诺·罗斯福(译者注:罗斯福夫人)都开始想到底还有没有人“能在今天做点事去拯救美国”了)，这样罗斯福那种亲切但是含糊，事不关己高高挂起的态度就显得有些不负责任了。人们觉得他应该去做些什么事情——不过倒没有人指望他比指望那位将要下台的总统更多。 十一月，总统向当选总统发了一封电报，提议他们应该进行一次商谈。罗斯福在去佐治亚州的路上顺路去了趟白宫，但尽管他们的商谈一直持续到了那天的后半夜，这场商谈却什么也没谈成。胡佛的一位内阁成员议论罗斯福道“我们现在在深渊里有一位难兄难弟了，并且他也没有能力把我们救出去。”不过能让罗斯福爬不出来的洞还没被挖好呢，多少个小时里，他不停地拒绝了登上行政机关那将沉的船的邀请。在这次拜访后，罗斯福感到他不轻率做出承诺的信念愈加坚定了，他是在温泉疗养院读报纸时学到这种智慧的。胡佛向国会发表了他的最后一篇国情咨文，其中不过是他那些陈词滥调的一再重复：税还要继续加收；欧洲必须支付他们在战时欠下的债务；“我们已经建立了一种个人主义的体系。在我们美国体系的背后，我们必须允许社会与经济力量自由自由地发挥作用”；国家必须有“对未来的信心”…. 美国的耐心快要耗尽了，它的钞票也是。在1933年的情人那天，胡佛在共和党全国代表大会之前做了他的告别演讲，而美国的银行系统也在这一天迎来了它的最终瓦解。那天下午，密西根州长威廉姆·A·卡姆斯托克接到了一通紧急电话，请他去底特律市中心参加一场银行家的会议，此后他便一直是其中的一员了。底特律的联合守护信托公司已山穷水尽，如果它倒闭，这座城里的每家银行恐怕都要为它陪葬，故而那些金融家请求卡姆斯托克能在全州范围内宣布银行暂停营业。那天半夜他同意了，开车回到首府兰辛州后，他发布了一条公告，将全州的550家银行关闭八天，他把这叫做一个假期。 在华盛顿，胡佛给罗斯福写了一封信，他当时心急如焚，以至于连信封上他继任者的名字都写错了。当选总统已经习惯于各种风浪了(就在上一周，一名失业的瓦匠向他开枪，却不小心打到了他身边的芝加哥州长梅尔·柯马克)，不过这份通讯在这些风浪中也算更加令人发指的那一种。罗斯福认真读了一遍，然后称它“无耻”。这封信也的确就是这样。胡佛无力地称国家对新政府想要做的事情感到恐慌。以爱国主义和“自信心”的名义，他还要求罗斯福公开承诺不会修改政府的方针。将要卸任的总统当然完全知道他正在要求什么东西；他向宾夕法尼亚州的参议员戴维·A·里德写道“我意识到如果这些宣示是由当选总统做出的，他将会批准共和党行政的所谓整体主要计划；这也就是说，他新政的百分之九十都将被废止。”他已经告诉朋友们，他觉得罗斯福就是一个友善的软柿子，现在他根本就是把罗斯福当一个蠢货来对待。而当他输掉了选举时，他的心思又变了：对亨利·史汀生他说罗斯福就是“一个疯子”。 当选总统此时也未必确信他有没有把自己绑到胡佛政策的贼船上，但他确信在那种政策下，整个国家马上就要崩溃了。 在房产价值的“跳水”下，密西根州的危机愈发严重，而这种危机是全国性的。自大萧条以来，5500家银行已经破产；公众们以委婉的词语来讲，“很紧张”。他们的紧张转化为囤积货物的行动。黄金以每天两千万美元(译注:美国当时实行金本位制，2000万美元约换30吨黄金)的速度从金库中被换走，换不到金子的储户也要取走纸币，以至于在作为货币基石的黄金储量见底的情况下，财政部还被要求扩大它的货币储量。 涉及银行的恐慌总是自杀性的。在这场危机之中，无论如何，形势总是或多或少地被三年的通缩给复杂化了。最保险的那些担保与安全机构之价值也大幅下跌到只剩它们初始值的一点。全美国的18569家银行共有大约六十亿美元现金，可却要承担410亿美元的存款，那些银行家被迫变卖他们的按揭债券与证券，故而损失惨重。 现在密西根州的银行也都倒闭了，全国的银行仅剩的那点黄金，每日的流出量也陡然升到了三千七百万美元；每天被取出的存款则高达1.2亿多美元。各地的银行都挤满了绝望的想要取钱的存户——在布朗克斯州有一位年轻的妈妈做起了出租她的孩子的生意：25美分一趟，租到孩子的女人便可依次要求插队并优先取款。二月二十日那周，参众两院都在忙着为取消禁酒令而大呼小叫，巴尔的摩信托公司则在周五那天支付出去了1300万美元，这几乎是它的半个家底了。在上一个周五，州长阿尔伯特·C·里奇宣布马里兰州的二百多家银行歇业，成为了第二个倒下的州。 为了振作信心，那些有责任心的人们不得不刻意地下功夫来保持他们的态度。《底特律新闻》评论道“我们未来将会回首这段经历，然后付之一笑”《巴尔的摩太阳报》振奋道“生活……总会像之前那样被各种可喜或是不可喜的事情重新填满。而且相比以往，我们还会多出一份属于我们大家额外的谈资。”巴尔的摩商会的主席说他看不出贸易不能恢复如常的理由；国税局则发出一份言辞激烈的备忘录，要求在两周内缴税。 伦敦那边没有什么能打破这虚幻的幻景的消息。依罗伯特·舍伍德所讲，罗斯福清楚他有一个优势——那就是他是一个“好榜样”。作为把握时机的老手，罗斯福清楚胡佛的退场有多狼狈不堪，他自己的登场就会有多光彩耀人。如果说他在自己没到桥头就不过桥就是不负责的话——更何况他那时实在也很难说能做些什么——这至少也是一种对美式政治传统的遵循。就像查尔斯·A·贝尔德指出，直到林肯被赋予权力之前，他都“从未把自己纳入那种可以无条件地从心所欲的系统中。他理解这些东西，但从未把自己投身到其中。”同样地，在财政秘书的选择上，罗斯福也展现出了这样宝贵的品质——他选了一位略显淘气的铁路设备制造商，他戴着遮丑用的假发，喜欢讲双关语，收藏五美元的银币，一有业余时间就去给吉他编曲。一周后，当新的行政团队入驻办公室时，全国人都认为这位威廉姆·H·伍丁精力充沛、思维机敏；但在一夜之前，他还只被记作是一首儿歌的编曲者:\n\n让我们像蓝鸲一样，\n整日地寻欢作乐，\n忘却所有的烦恼,\n在明媚的歌声之中。\n\n\n那周天，也就是二月二十六日，在印第安纳波利斯和阿克伦市，银行们宣布取款将被限制到存款的5%。在那天夜里，俄亥俄州的其他城市的十多家机构也加入了这个队伍，到了周一——在德国国会被熊熊烈火吞没，日本部队踏入中国满洲地区的同时——这么干的银行数量已经达到了三位数。过河到辛辛那提市，五家卡温顿和肯塔基的银行也采用了类似的限制措施。周一晚上，宾夕法尼亚州长吉福德·平肖签署了一项法案，批准个体机构可以按自愿歇业，托马斯·W·拉蒙特像伦敦发报说，依J.P.摩根来看，“紧急事态不可能再扩大了”。 然而紧急事态就是扩大了。到了周三也就是三月一日，着急忙慌的十七州州长们纷纷宣布银行歇业。平肖做的过于当机立断，以至于在观看五天后的总统就职典礼时，他口袋里只有95美分了。路易斯安那州的奥斯卡·K·艾伦州长取出华盛顿发给他的薪水后就留下一条武断关闭所有银行的条款，然后跑路了。在周三，当选总统——他现在根据阿瑟·克拉克在《纽约时报》报道，被负责任的人们要求掌握权力了——驱车从他东65街的房子前往去与伍丁会晤。他们一直到周四下午才露面，随即伴着20辆摩托车的嘶吼，他们顺着第五大道向下，又向西到哈德逊河乘轮渡。那天早上，纽约市曾飘过一阵小雪。纽约市民们静静地矗立着，凝视着游行的车马。在无线电城音乐厅外，一位纸糊的“大金刚”刚被建成以戏剧化它曼哈顿之旅的第一站，它的脸上露出一丝奸笑。在河上，那艘法式轮船“巴黎号”静静地在泊位停靠着，它的货舱被预留着——尽管当选总统的宴会里还无人知道这回事——是将被运走的价值九百万美元的黄金。在轮渡的另一边，一架B&O(译者注:不是今天卖音响的那个)货运火车正在等待，而那天下午，那位富兰克林·罗斯福，将会在与伍丁关切银行，与法利(译者注:罗斯福的邮政署长)畅谈信仰的路上，在轰鸣中穿过冰冷的雾气，抵达华盛顿特区。\n当他们抵达联合车站时，首都正雨雪交加。五月花酒店的总统套房里有一沓电报正等待着罗斯福:银行不是已经关闭，就是在关闭的路上；全国21个州，外加哥伦比亚特区和联邦储备的数据显示，这一周里黄金储备已经减少了2.26亿美元；财政局的钱已经不足以支撑联邦资金链了，就更不用说那些将于三月十五日到期的短期借款了。当选总统\n(后面还没写完)"
  },
  {
    "objectID": "posts/linuxc/index.html",
    "href": "posts/linuxc/index.html",
    "title": "《Linux C编程一站式学习》习题解答",
    "section": "",
    "text": "学这本书主要是为了满足ysyx的要求,故会先以一个较快的速度更新完ysyx要求的部分(第1-9章, 第11-16章, 第21章, 第23-25章, 以及第26章第1节),未经特殊标记的程序默认采用C17标准编译通过。\n编译环境:AMD Ryzen 7 7840HS,EndeavourOS x86-64,Linux 6.12.10,gcc 14.2.1(标了C23的用的是15.0)；跑不通的建议先想想是不是Windows的问题,再想想是不是英特尔的问题,再想想是不是Clang的问题\n你可以在这里读到这本书: https://akaedu.github.io/book/index.html"
  },
  {
    "objectID": "posts/linuxc/index.html#第二章",
    "href": "posts/linuxc/index.html#第二章",
    "title": "《Linux C编程一站式学习》习题解答",
    "section": "第二章",
    "text": "第二章\n\n习题2-2\n#include &lt;stdio.h&gt;\nint main(void)\n{\n    printf(\"%%\\n\");\n}\n\n\n习题2-5\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\nint main(void)\n{\n    printf(\"%d\\n\",(int)ceil(17.0/4));\n}"
  },
  {
    "objectID": "posts/linuxc/index.html#第三章",
    "href": "posts/linuxc/index.html#第三章",
    "title": "《Linux C编程一站式学习》习题解答",
    "section": "第三章",
    "text": "第三章\n\n习题3-3\n\n1.\n不能increment里的x是形参，不会影响传进去的实参\n\n\n2.\nprintf在stdio.h里，不把stdio.h给include进去的话printf没有定义"
  },
  {
    "objectID": "posts/linuxc/index.html#第四章",
    "href": "posts/linuxc/index.html#第四章",
    "title": "《Linux C编程一站式学习》习题解答",
    "section": "第四章",
    "text": "第四章\n\n习题4-1\n错误:if的条件满足后会执行一个空语句，下面那行并没有被if的判定所限制\n编译能通过:没有语法错误\n\n\n习题4-2\n\n1.\nx%10;(int) (x%100)/10\n\n\n2.\nvoid printdigit(int x)\n{\n    printf(\"%d,%d\\n\",x%10,(int) (x%100)/10)\n}\n\n\n\n习题4-3\n\n1.\nif (x&gt;=10 || x&lt;=0)\n    printf(\"x is out of range\\n\");\n\n\n2.\nif (x&lt;=0 && y&lt;=0)\n    printf(\"test failed!\\n\");\nelse\n    printf(\"test ok!\\n\");\n\n\n3.\ny=1 || x=1\n\n\n4.\n总之是第二个"
  },
  {
    "objectID": "posts/linuxc/index.html#第五章",
    "href": "posts/linuxc/index.html#第五章",
    "title": "《Linux C编程一站式学习》习题解答",
    "section": "第五章",
    "text": "第五章\n\n习题5-1\n\n1.\n请用C23编译\n\nbool is_leap_year(int year)\n{\n    if(year%4!=0 || (year%100==0 && year%400!=0))\n        return false;\n    else\n        return true;\n}\n\n\n2.\n#include &lt;math.h&gt;\ndouble myround(double x)\n{\n  if(x&lt;0)\n    return ceil(x-0.5);\n  else \n    return floor(x+0.5);\n}\n用gcc编译的话请加入-lm参数,我也不知道这个大哥为什么默认不会去找math.h\n\n\n\n习题5-3\n\n1.\nint euclid(int a, int b)\n{\n    if (a%b==0)\n        return b;\n    else\n        return(euclid(b,a%b));\n}\n证明交给屏幕前的各位未来的yau们自己完成(\n\n\n2.\nint fibo(int n)\n{\n    if (n==0||n==1)\n        return 1;\n    else\n        return(fibo(n-1)+fibo(n-2));\n}"
  },
  {
    "objectID": "posts/linuxc/index.html#第六章",
    "href": "posts/linuxc/index.html#第六章",
    "title": "《Linux C编程一站式学习》习题解答",
    "section": "第六章",
    "text": "第六章\n\n习题6-1\n\n1.\n用循环写递归本质上就是让你的脑子递归\n\n(1).\nint euclid(int a,int b)\n{int remain = 1;\nwhile (remain!=0)\n{\n    remain = a%b;\n    a = b;\n    b = remain;\n}\nreturn a;}\n\n\n(2).\nint fib(int n){\nint fibo[100];\nfibo[0]=1;\nfibo[1]=1;\nfor(int i = 2;i&lt;=n;i++)\n{\n    fibo[n]=fibo[n-2]+fibo[n-1];\n}}\n\n\n\n2.\nint nine(void){\nint nines=0;\nfor(int i = 1;i&lt;101;i++)\n{\n    if ((i%10)==9||((int) i/10) == 9)\n    nines++;\n}\nreturn nines;\n\n\n\n习题6-4\n\n1.\n#include &lt;stdio.h&gt;\nint is_prime(int n)\n{\n    int i=2;\n    while(i &lt; n && (n % i) !=0)\n        i++;\n    if (i == n)\n        return 1;\n    else\n        return 0;\n}\n\nint main(void)\n{\n    int i;\n    for (i = 1; i &lt;= 100; i++) {\n        if (is_prime(i))\n        printf(\"%d\\n\", i);\n    }\n    return 0;\n}\n\n\n2.\n可能会有某几次循环表达式3没有被执行\n\n\n\n习题6-5\n\n1.\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int i, j;\n    for (i=1; i&lt;=9; i++) {\n        for (j=1; j&lt;=9; j++)\n            if(j&lt;=i)    \n            printf(\"%d\\t\", i*j);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n\n2.\nvoid diamond(int n,char s)\n{\n  if(n%2==0)return;\n  for(int i = 1;i&lt;=n;i+=2)\n  {\n    for(int t = 0;t&lt;(n-i)/2;t++)printf(\" \");\n    for(int t = 0;t&lt;i;t++)\n      printf(\"%c\",s);\n    printf(\"\\n\");\n  }\n  for(int i = n-2;i&gt;0;i-=2)\n  {\n    for(int t = 0;t&lt;(n-i)/2;t++)printf(\" \");\n    for(int t = 0;t&lt;i;t++)\n      printf(\"%c\",s);\n    printf(\"\\n\");\n  }\n}"
  },
  {
    "objectID": "posts/linuxc/index.html#第七章",
    "href": "posts/linuxc/index.html#第七章",
    "title": "《Linux C编程一站式学习》习题解答",
    "section": "第七章",
    "text": "第七章\n\n习题7-2\n\n1.\n#include &lt;stdio.h&gt;\nstruct complex_struct{\n    double x,y;\n};\nvoid output_complex(struct complex_struct a){\n    if(a.x!=0)\n  {\n    printf(\"%.2lf\",a.x);\n    if(a.y!=0)printf(\"+\");\n    else printf(\"\\n\");\n  }\n\n  if(a.y!=0)\n    printf(\"%.2lfi\\n\",a.y);\n}\nint main(void)\n{\n    struct complex_struct a = {1,2};\n    struct complex_struct b = {0,1};\n    struct complex_struct c = {1,0};\n    output_complex(a);\n    output_complex(b);\n    output_complex(c);\n}\n\n\n2.\n#include &lt;stdio.h&gt;\n\nstruct rational{\n  int num,deno;\n};\n\n\nint euclid(int a, int b)\n{\n    if (a%b==0)\n        return b;\n    else\n        return(euclid(b,a%b));\n}\nstruct rational elliminate(struct rational c)\n{\n  int factor = euclid(c.num,c.deno);\n  c.num = c.num/factor;\n  c.deno = c.deno/factor;\n  return c;\n}\nstruct rational add_rational(struct rational a, struct rational b)\n{\n  struct rational sum;\n  sum.num = a.num*b.deno + b.num*a.deno;\n  sum.deno = a.deno*b.deno;\n  sum = elliminate(sum);\n  return sum;\n}\nstruct rational sub_rational(struct rational a, struct rational b)\n{\n  struct rational differ;\n  differ.num = a.num*b.deno - b.num*a.deno;\n  differ.deno = a.deno*b.deno;\n  differ = elliminate(differ);\n  return differ;\n}\nstruct rational mul_rational(struct rational a, struct rational b)\n{\n  struct rational product;\n  product.num = a.num*b.num;\n  product.deno = a.deno*b.deno;\n  product = elliminate(product);\n  return product;\n}\nstruct rational div_rational(struct rational a, struct rational b)\n{\n  struct rational quotient;\n  quotient.num = a.num*b.deno;\n  quotient.deno = a.deno*b.num;\n  quotient = elliminate(quotient);\n  return quotient;\n}\nstruct rational make_rational(int a, int b)\n{\n  struct rational c;\n  c.num = a;\n  c.deno = b;\n  return c;\n}\nvoid print_rational(struct rational a)\n{\n  if(a.deno!=1)\n    printf(\"%d/%d\\n\",a.num,a.deno);\n  else\n    printf(\"%d\\n\",a.num);\n}\nint main(void)\n{\n    struct rational a = make_rational(1, 8); /* a=1/8 */\n    struct rational b = make_rational(-1, 8); /* b=-1/8 */\n    print_rational(add_rational(a, b));\n    print_rational(sub_rational(a, b));\n    print_rational(mul_rational(a, b));\n    print_rational(div_rational(a, b));\n\n    return 0;\n}\n\n\n\n习题7-3\n\n1.\n\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nenum coordinate_type { RECTANGULAR, POLAR };\nstruct complex_struct {\n    enum coordinate_type t;\n    double a, b;\n};\nstruct complex_struct make_from_real_img(double x, double y)\n{\n    struct complex_struct z;\n    z.t = RECTANGULAR;\n    z.a = x;\n    z.b = y;\n    return z;\n}\nstruct complex_struct make_from_mag_ang(double r, double A)\n{\n    struct complex_struct z;\n    z.t = POLAR;\n    z.a = r;\n    z.b = A;\n    return z;\n}\n\ndouble real_part(struct complex_struct in)\n{\n  if (in.t == RECTANGULAR)\n    return in.a;\n  else \n    return (in.a*cos(in.b));\n}\n\ndouble img_part(struct complex_struct in)\n{\n  if (in.t == RECTANGULAR)\n    return in.b;\n  else \n    return (in.a*sin(in.b));\n}\n\ndouble magnitude(struct complex_struct in)\n{\n  if (in.t == POLAR)\n    return in.a;\n  else \n    return sqrt(in.a*in.a+in.b*in.b);\n}\n\ndouble angle(struct complex_struct in)\n{\n  if (in.t == POLAR)\n    return in.b;\n  else \n    return atan(in.b/in.a);\n}\n\nint main(void)\n{\n  struct complex_struct a = make_from_real_img(2,3);\n  struct complex_struct b = make_from_mag_ang(1,2);\n  printf(\"%lf %lf %lf %lf %lf %lf %lf %lf\\n\",real_part(a),real_part(b),img_part(a),img_part(b),magnitude(a),magnitude(b),angle(a),angle(b));\n  return 0;\n}\n使用gcc编译时请加入-lm指令，main函数主要是用来测试\n\n\n2.\nenumtest.cast\ncols: 80\nrows: 7\nautoPlay: true\nspeed: 4\ntheme: nord\nposter: \"npt:1:23\"\n原因:enum里的RECTANGULAR被后边的初始化语句在main里给覆盖了，而POLAR则还是定义的2"
  },
  {
    "objectID": "posts/linuxc/index.html#第八章",
    "href": "posts/linuxc/index.html#第八章",
    "title": "《Linux C编程一站式学习》习题解答",
    "section": "第八章",
    "text": "第八章\n\n习题8-1\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nint main(void)\n{\n  int a[5]={5,4,3,2,1};\n  int b[5];\n  memcpy(b,a,sizeof(a));\n}\n\n\n习题8-2\nrand()%11+10"
  },
  {
    "objectID": "posts/linuxc/index.html#第十章",
    "href": "posts/linuxc/index.html#第十章",
    "title": "《Linux C编程一站式学习》习题解答",
    "section": "第十章",
    "text": "第十章\n暂缺…"
  },
  {
    "objectID": "posts/linuxc/index.html#第十一章",
    "href": "posts/linuxc/index.html#第十一章",
    "title": "《Linux C编程一站式学习》习题解答",
    "section": "第十一章",
    "text": "第十一章\n\n习题11-4\n#include &lt;stdio.h&gt;\nint a[10]={1,2,3,4,5,6,7,8,9,0};\nint partition(int start, int end)\n{\n    /*从a[start..end]中选取一个pivot元素（比如选a[start]为pivot）;\n    在一个循环中移动a[start..end]的数据，将a[start..end]分成两半，\n    使a[start..mid-1]比pivot元素小，a[mid+1..end]比pivot元素大，而a[mid]就是pivot元素;*/\n    int mid = (int) (start+end)/2;\n  for (int i = start;i&lt;mid;i++)\n  {\n    if(a[i]&gt;a[mid])\n    {\n      int temp=a[i];\n      for(int t = i;t&lt;mid;t++)\n      {\n        a[t]=a[t+1];\n      }\n      a[mid]=temp;\n      mid--;\n    }\n  }\n  for (int i = end;i&gt;mid;i--)\n  {\n    if(a[i]&lt;a[mid])\n    {\n      int temp=a[i];\n      for(int t = i;t&gt;mid;t--)\n      {\n        a[t]=a[t-1];\n      }\n      a[mid]=temp;\n      mid++;\n    }\n  }\n\n  return mid;\n}\n\nvoid quicksort(int start, int end)\n{\n    int mid;\n    if (end &gt; start) {\n        mid = partition(start, end);\n        quicksort(start, mid-1);\n        quicksort(mid+1, end);\n    }\n}\n\nint main(void)\n{\n  quicksort(0,9);\n  for(int i = 0;i&lt;10;i++)printf(\"%d\\n\",a[i]);\n}\n我估计这个应该不是最优算法,在原书内含和partition函数以外的部分都是用于测试\n\n\n习题11-5\n\n1.\n没有，至少得把每个元素都遍历一遍才能确定是最小的\n\n\n2.\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n  int data[5] = {1,2,3,4,5};\n  int min=1,second=2;\n  for(int i = 1;i&lt;5;i++)\n  {\n    if (data[i]&lt;=second && data[i] &gt;= min)\n      second = data[i];\n    else if (data[i]&lt;=min)\n      min = data[i];\n  }\n  printf(\"%d\\n\",second);\n}\n我不是很确定这个的复杂度算不算是n\n\n\n3.\n#include &lt;stdio.h&gt;\n\n\nint a[5] = {1,2,3,4,5};\n\nint partition(int start, int end)\n{\n    int mid = (int) (start+end)/2;\n  for (int i = start;i&lt;mid;i++)\n  {\n    if(a[i]&gt;a[mid])\n    {\n      int temp=a[i];\n      for(int t = i;t&lt;mid;t++)\n      {\n        a[t]=a[t+1];\n      }\n      a[mid]=temp;\n      mid--;\n    }\n  }\n  for (int i = end;i&gt;mid;i--)\n  {\n    if(a[i]&lt;a[mid])\n    {\n      int temp=a[i];\n      for(int t = i;t&gt;mid;t--)\n      {\n        a[t]=a[t-1];\n      }\n      a[mid]=temp;\n      mid++;\n    }\n  }\n\n\n  return mid;\n}\n\nvoid quicksort(int start, int end)\n{\n    int mid;\n    if (end &gt; start) {\n        mid = partition(start, end);\n        quicksort(start, mid-1);\n        quicksort(mid+1, end);\n    }\n}\n\nint order_statistic(int start, int end, int k)\n{\n    int i = partition(start,end);\n    if (k-1 == i)\n      return a[i];\n    else if (k &gt;= i)\n  {\n    quicksort(i+1,4);\n    return a[k-1];\n  }\n    else\n  { \n    quicksort(0,i-1);\n    return a[k-1];\n  }\n}\n\nint main(void)\n{\n  printf(\"%d\\n\",order_statistic(0,4,1));\n}\nds说这个的平均复杂度接近\\[n^2\\],我不太相信但是这个的平均复杂度肯定比n大得多，我还需要再钻研一下。"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Oscar Tuo’s Blog",
    "section": "",
    "text": "《CS:APP》学习笔记(2)信息的表示与处理\n\n\n\nsystem\n\n\n\n\n\n\n\n\n\nNov 6, 2025\n\n\nOscar Tuo\n\n\n\n\n\n\n\n\n\n\n\n\n《CS:APP》学习笔记(1)计算机系统巡游\n\n\n\nsystem\n\n\n\n\n\n\n\n\n\nOct 31, 2025\n\n\nOscar Tuo\n\n\n\n\n\n\n\n\n\n\n\n\nCS61B要点速记\n\n\n\nJava\n\n\n\n\n\n\n\n\n\nSep 23, 2025\n\n\nOscar Tuo\n\n\n\n\n\n\n\n\n\n\n\n\n《Linux C编程一站式学习》习题解答\n\n\n\nprogramming\n\n\n\n\n\n\n\n\n\nJan 29, 2025\n\n\nOscar Tuo\n\n\n\n\n\n\n\n\n\n\n\n\n《荣光与梦想——美国历史纪实：1932-1972年》 序章:冰点\n\n\n\ntranslation\n\n\n\n\n\n\n\n\n\nJan 27, 2025\n\n\nOscar Tuo\n\n\n\n\n\n\n\n\n\n\n\n\n新年特辑 | 翻译 《荣光与梦想——美国历史纪实：1932-1972年》第二章·“罗斯福！”\n\n\n\ntranslation\n\n\n\n\n\n\n\n\n\nJan 27, 2025\n\n\nOscar Tuo\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/glory1/index.html",
    "href": "posts/glory1/index.html",
    "title": "《荣光与梦想——美国历史纪实：1932-1972年》 序章:冰点",
    "section": "",
    "text": "在1932年那个绝望的夏天，华盛顿特区宛若一座被团团包围的欧洲小国首都。这座城市自从五月，两万五千名一贫如洗的一战老兵携妻带子在其中的公园里、垃圾堆里、废旧仓库以及空商店里安营扎寨后便如此了。在一位荣誉奖章获得者的带领下，在华盛顿万千居民沉默的注视下，老兵们四处行军、大唱军歌；他们身披褪色的棉质美国国旗，在宾州大道上游行。然而，在大部分时间他们也只是等待着并忧愁着。老兵们到首都是为了向政府索要属于他们的大萧条救济品，而年关也将要到了；他们尤其想要的是那笔在1924年便于《调整后赔偿金法案》中许诺给他们(但一直到1945年也没给)的津贴能立即支付给他们。如果他们能得到这笔钱，每个人便都能得到大约500美元的收入。头条文章作者称他们是“津贴部队”“寻求补贴的游行者”，他们的自称则是“津贴远征军”。\n津贴远征军希望国会能采取行动，然而希望却落空了。于是他们便开始祈求胡佛总统，希望他能听听他们中的领导代表的意见。然而胡佛总统只是传了句话，说他太忙了，然后便继续远离喧嚣、与世隔绝了。总统前往参议院的计划也搁置了，警察在白宫旁日夜巡逻。自停战(译注:南北战争停战)后，这还是这座执行机关的大门首次因故紧闭。胡佛总统把自己锁在白宫里，《纽约每日新闻》的头条赫然载着。他还干了更过分的；路障被高高立起，因为白宫这一处的封路，来自四方，甚至是两三百米的交通都被切断。一名独臂的老兵在进行纠察时试图穿越警卫的屏障，结果他被痛打了一顿然后被捕入狱。\n站在今天回看当时，这种种景象好像是政府草木皆兵，在忙乱之中的过度反应。“远征军”不仅手无寸铁，而且也已经将那些激进分子清除出了他们的队伍；甚至尽管他们的饥饿已然肉眼可见，他们依然没有当街乞讨。他们早已虚弱不堪，虚弱到当不成暴民了。一位名叫德鲁·皮尔森的三十四岁《巴尔的摩太阳报》记者形容他们道“衣衫褴褛，疲惫不堪，麻木不仁”，而且“脸上看不到一点希望”。“远征军守夜”活动规模日见增长，仿佛已然成为了对耐力的一种锻炼形式。一位卫生部门的督察形容他们营地的卫生状况为“烂透了”。临危受命的“军需官”的工作十分仰赖慈善捐赠：一卡车一卡车的食物从他们在得梅因市以及新泽西州的凯姆登镇的朋友们那里拉来；每天都会一位有热心的烘焙师送来一百条面包，另一位则会送来一千个派；对外战争老兵协会送来了500美元，而“远征军”自己则靠在格里菲斯体育场举办一场场队员间的拳击赛又募集了2500美元。这一切都属于偶然。权力机关实际上什么忙都没有帮——华盛顿警局甚至因以每天6美分的价格为那些游行者提供面包和咖啡而惹怒了胡佛总统——等到八月中旬，酷暑的到来缩减了他们的水资源，也加剧了他们的苦楚。\n当时，华盛顿特区被英国外事办公室官方认定为“亚热带气候”，这也就是说那些外交官们十分憎恶这里难顶的酷热与浓密的湿雾；除了市中心几座标榜自己是“内含制冷设备”的大剧院外，再也没有哪里有空调了。在夏天，首都的生活只能是在遮阳棚下，在门廊的阴凉下，在载着冰块的马车旁，在专属夏日的家具中盖着夏日的薄毯子度过；有一本官方的旅游手册也声称“这时的首都对于想要研究虫子的人来说妙趣横生”。既没有阴凉处，也没有遮阳屏，“远征军”只得直面太阳的盛光。当老兵们的头排刚进入特区时，城市正是春暖花开之时。但是等到了九月，不仅木兰与杜鹃花早已凋谢，樱桃树也是光秃秃的了。夸张地来说，整个地球都因此而显得冷峻了几分。而游行的老兵们则活像是一些沙漠植物，市中心的老板们抱怨说“这么多穷鬼在街上走着，我生意都不好了”，然而这些老兵对国家的危害其实也就仅限于此了。\n然而，尽管“远征军”的所谓威胁是政府草木皆兵的幻想，华盛顿当局对国际形势的暧昧态度以及它对欧洲的高度依赖却是实实在在的。在彼时全世界的六十五个独立国家中，有且仅有一个超级大国、力量中心——那便是英国。米字旗覆盖了全世界可耕种陆地的四分之一，这一“日不落帝国”的殖民地遍布世界，从欧亚非，到北中南美洲，再到西印度群岛，英国的领土上太阳真的永远不会落下。全世界有4.85亿人都对大英帝国俯首称臣，而“像英格兰银行一样安全“则与”和直布罗陀巨石一样坚固“一同，成为了稳固的代名词。彼时4.86美元才能换得一英镑，这也说明了英国财政的无比安全。空军在那时还无人问津，只有一些默默无闻的飞行员和一位名叫米歇尔的被撤职美国将军才梦想着去发展它；而那时被重视的则是海军，而那时世界的主要水路却全都被伦敦政府所占据。直布罗陀海峡、亚丁湾、新加坡海峡和好望角都被英国海军部牢牢掌握。福克兰群岛上有英国海军站统领麦哲伦海峡，甚至巴拿马运河也为女王陛下麾下的“加勒比中队”所监视。这所带来的结果是，美国就如英国其他任何的殖民地一样，确认无误地被英国皇家海军所护卫着。伦敦的劳合社保险公司甚至为针对美国的任何入侵提供500比1的赔付。当《财富》杂志向它的读者保证太平洋和大西洋“无论面对多快的战舰或是飞机，都会在现在与未来一直处于保护之下”时，他们假定了自美国建国以来便始终主宰着大海上每一股浪涛的英国海军还将永远主宰着海洋。\n华盛顿当局也是这么想的。当时的美国无论从国力、愿景，还是从组织架构来看，都既无心也无力去成为一个超级大国。夏日的首都活像一个昏昏沉沉的乡村（在其他时候也没有什么人会记得它）。华盛顿那时仅仅只是美国第14大城市，而这个国家大部分重要事务都被放在了纽约解决——因为那里是财富汇聚的金融中心；需要采取联邦行动的时候，曼哈顿区大公司的那些律师们——比如查尔斯·埃文思·修斯、亨利·刘易斯·史汀生和伊莱休·鲁特等人——便会进京去指导他们的共和党同僚们。柯立芝总统通常在吃饭前就会完成他的公务。胡佛则因为成为第一个在他的办公桌上安装电话的总统而引发了不小的争议；他还创纪录地雇佣了五个秘书——在此之前的美国总统的秘书数量还从未超过一个——他甚至编排了一套复杂的传呼系统来呼叫这五个秘书。\n雾底街区——美国国务院现在的所在地，在那时还只是一片黑人的贫民窟。如今的五角大楼在那时则是一个农业试验基地，呈出一片标准的华盛顿郊外景象。《星期六每日邮报》观察到“就在国家的核心立法机关近旁，还有相当大的一部分土地在被农民耕种着。”为政府所雇佣的外事工作者还不到两千人。更令人震惊的是，国务院、陆军部、海军部那时都屈居在同一栋楼的同一层，那处面目狰狞、耀武扬威的“雕梁画栋”现在被人们叫做艾森豪行政办公大楼。当然，在1929年白宫被一把火烧得面目不堪时，总统和他的幕僚们也不得不搬进了这座大楼，而这些官僚中甚至没有一人感觉到这里太挤了。那时白宫还远没有今日这般的排场，那如今驻扎着驻外武官和外交秘书的东厢彼时还没有兴建；特勤局也还没有将西行政大道整个封锁，它彼时只不过是一条普通的大街，你随意哪天都大可在上面安营扎寨，即使你的距离已经足以轻松地往白宫里扔石头。如果你对着特勤局的特工喊一声，他可能会在大门口会一会你。陆军参谋总长道格拉斯·麦克阿瑟也在这一层办公，他用一扇木板门把自己分隔了出来；当他需要辅助时，只需要喊一声“艾森豪威尔上校！”，艾克便得匆匆赶到。\n有一位匿名的《财富》杂志撰稿人，形容麦克阿瑟将军说什么“不善表达，对公众不加掩饰地真诚”，这就是纯粹的胡说八道；麦克阿瑟甚至在那个时候就已经在讲话时用第三人称自称，讲话时嘴里总是叼着一根长烟斗，他还在自己的工位身后安了面四米多高的大镜子，用来使自己的形象显得更加宏伟。艾森豪威尔后来回忆道：当麦克阿瑟觉得他自己可以自称是陷入了“居心叵测、粗鲁无礼、背信弃义、颠倒黑白、目中无人、歪门邪道、麻木不仁，会使世界走向永劫不复的深渊的政治职责的爆发“之中时，他便是无懈可击的。但是对于那些专以从军为生的士兵们来说，他们则度过了一段难熬的日子。对于上校以下军衔的军人们来说，他们晋升的唯一凭据便是年岁；在三十年代初，想从上尉升到上校要花足足二十二年。在这些日子里，他们只好看着日历苦等着。无聊的感觉是如此难挨，甚至艾森豪威尔都差点就因此辞职了；在那些年月里，他养成了阅读Street&Smith出版社的街头杂志的习惯：《双枪西部》、《西部故事》、《刺激西部》以及《牛仔小故事》等等。渡过梅尔堡附近的波托马克河，便能看到一位在1919年升至此职的名叫小乔治·S·帕顿的上校；他在每周三和周六的下午四点骑着那些已经为他赢得过400条丝带和200樽奖杯的马中的一匹打马球；他同时也因拥有一把带有象牙握把的左轮手枪而闻名；他在障碍赛马、猎狐、双向飞碟、滑翔飞行等等领域也均有追求。但是帕顿上校和艾森豪威尔上校也有不同之处，那就是他是个有钱人。\n没有什么比看一眼当时的军队建制更能向我们展现四十年前美国的地方主义有多么盛行了，只消一眼就够。彼时美国拥有世界第十六大军队，位居捷克斯洛伐克、土耳其、西班牙、罗马尼亚和波兰之后；身披全套军装、每月拿17.85美元工资的军人统共有132069人。从纸面数据来看，美国似乎有与南斯拉夫(军队规模138934人)硬碰硬的实力，然而现实中他们恐怕只会一败涂地；这是因为这些麦克阿瑟手下的军人中，大部分人都要么被安排到了文职工作、要么在美墨边境巡逻或是去保护属于美国的海域了；真正在美国本土的士兵不过三万余人——比1776年乔治国王派往美国平叛的军队规模还要更小。\n不仅如此，美国军队的素质也是差得可怕。彼时的军费不过是今日(译注：本书写于20世纪70年代)的四分之一，看起来也确实只值这些钱。《财富》杂志说它是世界上“装备最差”的军队，没有任何人对此观点提出异议。假如危机降临，麦克阿瑟可以调动1000辆均已过时坦克，1509架急速不足400公里每小时的飞机，仅有的一个机械化团(那年春天刚刚在诺克斯堡组建，由一些骑着马、穿着防芥子气的靴子的骑兵领队)。一位作家说，美国军队就是“以一副填不饱肚子、穿着不合身军装、歪歪扭扭端着枪的模样在广阔的大地上游荡”。\n麦克阿瑟当时是美国全国唯一的四星上将——其他人中甚至连一个三星的都没有。作为军队的首脑他年薪10400美元，在梅尔堡有一处住所，并且能独享军队里仅有的一辆豪华专车。作为他的副手，艾森豪威尔上校的地位其次，年薪3000美元。由于他同时还担任军队在议会的说客，他不得不频繁地往返国会山；但是他的上司从来没有借给他专车，也没有人给过他车马费；在那时的华盛顿，还未有人开过成立备用金基金这种东西的先例。因此，据他本人后来回忆，艾森豪威尔那时只能走到国会大厅的尽头去填一张表，这样他就能得到两张有轨电车的车票，然后他就去宾夕法尼亚大道马路边上等前往普莱森特山的有轨电车。\n我没要求你永远写翻译。我不是恶魔。\n可是，半年一点没写是什么意思呢？你的职业素养是怎么了？你才19岁吧？再这样下去，你40岁翻译不完序章，80岁还没翻译完第一章，最后带着一堆文件似了。\n作为你的正义人格，我可能得控制你了。真的。\n好在这个等待也不是很长。华盛顿那时布满了有轨电车轨道，街上有将近七百辆电车在提供服务；除了在冬天容易短路外，这些电车倒也还算高效。至于堵车，那是下一代人的的烦心事了。如果你开车去上班(限速22英里每时),车可以直接停在办公室门口：路边几乎永远都有空位。街上那些楔形汽车的品牌也是五花八门：帕卡德、斯庞蒂克、格雷汉姆、皮尔斯·箭头、特拉普兰以及斯图兹等等；鉴于行业标准还要迟一些才会出现，这些汽车眼下都还是小作坊出品。\n所有阶层的工作者(也包括人民公仆们)，周六早上都要上班。在夏天他们的季节性装扮往往是:白色亚麻布的”棕榈海滩风”或是棉质的西装；普通草帽或是巴拿马草帽；“软领”衬衣以及轻便的内衣。这种穿搭只能在最暖和的那几个月穿着，因为集中供暖是最近才有的事情，而且还远远谈不上普及1。在1932年，特区五大报纸的所有版面上都充斥着社会动荡的新闻，可其中没有一条是与黑人有关的。尽管那时首都便已有26%的人口为黑人，高居全美城市之首。黑人们空前一致地接受了他们极为惨淡的命运。一本政府指南解释道,“那些深色皮肤的南方孩子”被限制只能在国内从事服务业或是”手工业”。政府所属的商店、影院以及餐厅等等均不向他们开放。正在宾夕法尼亚大街上挖司法部新大楼的黑人工人们要么自己带饭，要么就只能挨饿；他们即使只是想要一杯水，也必须得步行两英里到第七街，才能找到一家愿意接待他们的饭店。霍华德大学作为黑人院校，其校长也是一位白人。当胡佛总统送金星母亲们2去法国时，黑人母亲们被安排到了另一艘船上，并且只能坐二等座。甚至当时全国最火爆的广播节目，名叫”爱默生与安迪”，简直就是一场夜里的种族侮辱秀。其中侮辱黑人的部分里，两名白人饰演黑人，像中世纪的艺人一样夸张地模仿着黑人的口音。\n黑人占据了华盛顿西南部的雾底街区，以及整个乔治敦。乔治敦那时还未被嗜好古色古香风格的人们所发掘，这或许是因为整个城市那个时候都很古色古香。特区那时也要相比现在更绿:每一位居民平均享受六棵遮阳树。最具有异域风情的街区就要数卡洛拉马高地和上马萨诸塞大道了。尽管每个犹太人都知道，那些豪华的宅邸都对他们“有所限制”，但是考虑到反犹太主义那时远没有白人至上主义那样的人气，而且那时甚至还没有以色列这个国家，这种事甚至都没有引起什么外交问题。现在在马萨诸塞大道上的使馆巷，那个时候建在第十六街上，距离白宫不过几步路的距离，那里面的大使个个都穿着条纹裤和夫拉克式上衣。即使他们在闹市区走路，也需要留意脚下，因为地上很多时候都是坑坑洼洼的。超市还只是加州的新鲜事物，而特区百姓要买食物，要么去杂货铺，要么就去红色门头的A&P杂货店，再或者就只能是开放市场或是街边小摊了。街头手风琴艺人3和推着小推车的小商贩在街上到处都是，还有走街串巷的磨刀匠呼唤家庭主妇，让她们把剪刀和菜刀拿出来磨利；在中心城区，花店和水果摊在街角留下了色彩斑斓的污渍；而牡蛎市场则在码头边茁壮生长；在宾夕法尼亚大道，现在的国家档案馆所在地，那时开着华盛顿特区市场。农贸市场在K街上——那是一个人潮涌动的壮观场面，尤其以其中鱼贩的叫卖与成排的死兔子而著称。市场大门口甚至有一只与活马尺寸相仿的木马——1932年时华盛顿特区还有数以千计的马在工作。K街的鹅卵石与那些珍贵的记忆以及混合着大市场与街角小贩气质的独特气味相得益彰，然而不久之后，它就被伟大的碎石路给取代了。\n即使在萧条期间，华盛顿特区也依然游客络绎不绝；但他们并不在华盛顿机场落地——直到1970年那里每天大概总共也只有24000名游客。那块如今忙乱的土地，那时也只是在波托马克河边静静悄悄；坐飞机出行是非常稀有的事。这个市场当时的情况是：航空公司甚至会要求每名空乘都是注册护士，与此同时那些客机(通常是福特三引擎型4)却一遇到夜晚或者坏天气就罢工了；更没有所谓跨洋航线这种东西。客机的平均时速只有155英里5；倚靠不停转机，一个人或许能在18小时内横穿美国，然后他的肖像就会上报纸。"
  },
  {
    "objectID": "posts/glory1/index.html#footnotes",
    "href": "posts/glory1/index.html#footnotes",
    "title": "《荣光与梦想——美国历史纪实：1932-1972年》 序章:冰点",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n本书写于上世纪70年代。↩︎\n在战争中丧子或丧女的母亲。↩︎\n这种街头艺人可能和common sense里的理解不太一样，他们是靠故意演奏难听的重复音乐来逼你给钱，你给钱他们就不演奏了。↩︎\n这种飞机至停产只卖了不到200架，不过考虑到前文中所说彼时的航空业规模之小，我暂且认为作者没有搞错。↩︎\n约248千米。↩︎"
  },
  {
    "objectID": "posts/CS61B/index.html",
    "href": "posts/CS61B/index.html",
    "title": "CS61B要点速记",
    "section": "",
    "text": "听CS61B听到第四节写disc发现前面忘光了，所以决定写个这个备作复习"
  },
  {
    "objectID": "posts/CS61B/index.html#main函数定义",
    "href": "posts/CS61B/index.html#main函数定义",
    "title": "CS61B要点速记",
    "section": "main函数定义",
    "text": "main函数定义\npublic static void main(String[] args)"
  },
  {
    "objectID": "posts/CS61B/index.html#static-typing",
    "href": "posts/CS61B/index.html#static-typing",
    "title": "CS61B要点速记",
    "section": "Static Typing",
    "text": "Static Typing\nJava变量必须有唯一确定的类型，一经定义不能改变"
  },
  {
    "objectID": "posts/CS61B/index.html#函数即方法",
    "href": "posts/CS61B/index.html#函数即方法",
    "title": "CS61B要点速记",
    "section": "函数即方法",
    "text": "函数即方法\nJava的所有函数必须在类内定义，也就是方法 一个项目里的类不用import就能用"
  },
  {
    "objectID": "posts/CS61B/index.html#实例和实例方法",
    "href": "posts/CS61B/index.html#实例和实例方法",
    "title": "CS61B要点速记",
    "section": "实例和实例方法",
    "text": "实例和实例方法\n类的实例化函数通过\npublic className(){\n}\n定义\npublic static typename funcname(){\n}\n这种是静态方法，可以直接从类名调用，但是相应地也调用不了实例的变量和函数\npublic typename funcname(){\n}\n这种是实例方法，实例化以后才可以调用，可以调用当前实例内的变量和其他方法\n实例化函数和实例方法不用把self当参数传入 通过self.funcname/ self.varname或者直接funcname/varname调用实例内变量与方法效果是一样的\n相似地，通过public static typename varname/funcname 可以定义静态变量，通过public typename varname/funcname 可以定义实例变量\n实例变量也必须在类的声明中声明，实例化以后不能再添加新的变量\n实例化后，实例只会引用其类的静态变量而不会专门初始化一个自己的，也就是说改了类里的静态变量它的实例都会跟着改\npublic的意思是同一个项目里的其他对象也可以访问，private是该类/该实例私有的\n如果变量/方法前边没有public也没有private，那么它就是package-private的，也就是对同一个package内public，之外则private，package需要自己定义"
  },
  {
    "objectID": "posts/CS61B/index.html#list",
    "href": "posts/CS61B/index.html#list",
    "title": "CS61B要点速记",
    "section": "List",
    "text": "List\n首先需要\nimport java.util.List\n但是\nList L = new List();\n不会被编译，这是因为List是一个抽象类(只作别人的基类，自己不能实例化) 需要\nimport java.util.ArrayList\n然后再\nList L = new ArrayList()\n或其他List类型，比如LinkedList\n也就是说:List是抽象数据类型，LinkedList/ArrayList等是它的具体实现\n通过\nL.get(0)\n可以索引列表\n通过\nList&lt;String&gt; L = new ArrayList&lt;&gt;()\n可以指定存储的数据类型\n\nArray\n一种特殊的类List实现，但不属于List ADT 通过\nint[] x = new int[5];\n即可声明，无需import任何包 但是容量必须声明固定，不包含任何内置方法，只能用[]来索引"
  },
  {
    "objectID": "posts/CS61B/index.html#map",
    "href": "posts/CS61B/index.html#map",
    "title": "CS61B要点速记",
    "section": "Map",
    "text": "Map\n也就是键值对 Map也是ADT，常用的实现有HashMap和TreeMap\nMap&lt;String, String&gt; L = new TreeMap&lt;&gt;();\n\n    L.put(\"dog\", \"woof\");\n\n    L.put(\"cat\", \"meow\");\nTreeMap自带升序排序，HashMap不会自动排序"
  },
  {
    "objectID": "posts/CS61B/index.html#primitive-types-reference-types",
    "href": "posts/CS61B/index.html#primitive-types-reference-types",
    "title": "CS61B要点速记",
    "section": "Primitive Types & Reference Types",
    "text": "Primitive Types & Reference Types\nbyte, short, int, long, float, double, boolean, char八种类型叫Primitive Type，也就是所谓的基本类型\n基本类型变量直接对应内存地址 使用类似\nint y = 1;\nint x = y;\n的语法从一个基本类型变量给另一个赋值时，会直接把源变量的所有字节直接复制给目标变量 其他的都是Reference Type,也就是引用类型，实际上就是对象 创建引用类型时会先创建一个该类型的对象并填入默认值，然后调用构造函数填入输入值，最后返回这个对象的一个64位的地址 也就是说引用类型里实际上存的只是地址，当你赋值的时候复制过去的时候也只是地址，那么就会发现两个引用类型变量却指向的是同一个对象\n函数里传参也遵守类似的规则 前面讲到的List、Array等等也是对象，因此使用==比较时实际上比较的是内存地址，要比较内容需要用equals"
  },
  {
    "objectID": "posts/CS61B/index.html#intlist",
    "href": "posts/CS61B/index.html#intlist",
    "title": "CS61B要点速记",
    "section": "IntList",
    "text": "IntList\npublic class IntList {\n\n   public int first;\n\n   public IntList rest;\n\n  \n\n   public IntList(int f, IntList r) {\n\n      first = f;\n\n      rest = r;\n\n   }\n    public int size() {\n\n      if (rest == null) {\n\n         return 1;\n\n      }\n\n      return 1 + this.rest.size();\n      }\npublic int iterativeSize() {\n\n      IntList p = this;\n\n      int totalSize = 0;\n\n      while (p != null) {\n\n         totalSize += 1;\n\n         p = p.rest;\n\n      }\n\n      return totalSize;\n\n   }\n   }\n课程里的这个IntList实际上是个链表\nsize是递归实现的size函数，iterativeSize则是迭代实现的"
  },
  {
    "objectID": "posts/csapp2/index.html",
    "href": "posts/csapp2/index.html",
    "title": "《CS:APP》学习笔记(2)信息的表示与处理",
    "section": "",
    "text": "内存中的最小可读写单元往往不是二进制位，而是由8个二进制位组成的字节。对程序而言，内存就是一个由字节组成的数组，也就是所谓虚拟地址空间，其中每个字节都有其独一无二的编号，称为地址。\n虚拟地址空间并不只是简单地给物理内存标序号，其实现比较复杂，在后文会详述。内存地址的一个典型应用场景就是C指针：指针内存储的就是所指向的内存地址。C编译器会针对指针指向的不同数据类型生成不同的机器码；当然，真正的机器码里就不存在数据类型了，对于它而言，指针指向的数据和它自身都只是一些字节串而已。"
  },
  {
    "objectID": "posts/csapp2/index.html#数据的存储",
    "href": "posts/csapp2/index.html#数据的存储",
    "title": "《CS:APP》学习笔记(2)信息的表示与处理",
    "section": "",
    "text": "内存中的最小可读写单元往往不是二进制位，而是由8个二进制位组成的字节。对程序而言，内存就是一个由字节组成的数组，也就是所谓虚拟地址空间，其中每个字节都有其独一无二的编号，称为地址。\n虚拟地址空间并不只是简单地给物理内存标序号，其实现比较复杂，在后文会详述。内存地址的一个典型应用场景就是C指针：指针内存储的就是所指向的内存地址。C编译器会针对指针指向的不同数据类型生成不同的机器码；当然，真正的机器码里就不存在数据类型了，对于它而言，指针指向的数据和它自身都只是一些字节串而已。"
  }
]